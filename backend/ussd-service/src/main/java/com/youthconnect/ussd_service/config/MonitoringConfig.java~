package com.youthconnect.ussd_service.config;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.Gauge;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
// No need to import Tags specifically for the builder pattern as it takes varargs of Strings
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.atomic.AtomicInteger;

@Configuration
@RequiredArgsConstructor
public class MonitoringConfig {

    private final MeterRegistry meterRegistry;

    // Atomic counters for gauges. These will be registered as gauges.
    private final AtomicInteger activeSessionsCount = new AtomicInteger(0);
    private final AtomicInteger queuedRequestsCount = new AtomicInteger(0);

    /**
     * Counter for tracking total USSD requests with tags for different categories.
     * Tags include: status (success/error), source, operator.
     * The `tags` method expects key-value pairs as varargs.
     */
    @Bean
    public Counter ussdRequestCounter() {
        return Counter.builder("ussd.requests.total")
                .description("Total number of USSD requests processed")
                // Correct usage of .tags() method
                .tags("status", "unknown", "source", "ussd", "operator", "default")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking security events and potential threats.
     * Tags include: event_type, severity, ip_address.
     */
    @Bean
    public Counter securityEventCounter() {
        return Counter.builder("ussd.security.events")
                .description("Security events and potential threats detected")
                // Correct usage of .tags() method
                .tags("event_type", "unknown", "severity", "low")
                .register(meterRegistry);
    }

    /**
     * Timer for measuring USSD request processing duration.
     * Helps identify performance bottlenecks and optimize response times.
     */
    @Bean
    public Timer ussdRequestTimer() {
        return Timer.builder("ussd.request.duration")
                .description("Time taken to process USSD requests")
                // Correct usage of .tags() method
                .tags("outcome", "unknown")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking user registration attempts.
     * Tags include: status (success/failure), failure_reason.
     */
    @Bean
    public Counter registrationCounter() {
        return Counter.builder("ussd.registration.attempts")
                .description("User registration attempts via USSD")
                // Correct usage of .tags() method
                .tags("status", "unknown")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking gateway service interactions.
     * Tags include: service_name, operation, status.
     */
    @Bean
    public Counter gatewayInteractionCounter() {
        return Counter.builder("ussd.gateway.interactions")
                .description("Interactions with backend gateway services")
                // Correct usage of .tags() method
                .tags("service", "unknown", "operation", "unknown", "status", "unknown")
                .register(meterRegistry);
    }

    /**
     * Timer for measuring gateway service response times.
     * Critical for monitoring backend service health and performance.
     */
    @Bean
    public Timer gatewayResponseTimer() {
        return Timer.builder("ussd.gateway.response.time")
                .description("Response time for gateway service calls")
                // Correct usage of .tags() method
                .tags("service", "unknown", "operation", "unknown")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking menu navigation patterns.
     * Tags include: from_menu, to_menu, user_choice.
     * Helps understand user behavior and optimize menu flow.
     */
    @Bean
    public Counter menuNavigationCounter() {
        return Counter.builder("ussd.menu.navigation")
                .description("Menu navigation patterns and user choices")
                // Correct usage of .tags() method
                .tags("from", "start", "to", "unknown")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking session management events.
     * Tags include: event_type (created/expired/terminated), reason.
     */
    @Bean
    public Counter sessionEventCounter() {
        return Counter.builder("ussd.session.events")
                .description("USSD session lifecycle events")
                // Correct usage of .tags() method
                .tags("event_type", "unknown")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking business operation outcomes.
     * Tags include: operation_type, success_status, district.
     */
    @Bean
    public Counter businessOperationCounter() {
        return Counter.builder("ussd.business.operations")
                .description("Business operations performed via USSD")
                // Correct usage of .tags() method
                .tags("type", "unknown", "status", "unknown")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking errors by category and severity.
     * Tags include: error_type, severity, component.
     */
    @Bean
    public Counter errorCounter() {
        return Counter.builder("ussd.errors")
                .description("Errors categorized by type and severity")
                // Correct usage of .tags() method
                .tags("type", "unknown", "severity", "medium")
                .register(meterRegistry);
    }

    /**
     * Timer for measuring database operation durations.
     * Tags include: operation_type (read/write), table_name.
     */
    @Bean
    public Timer databaseOperationTimer() {
        return Timer.builder("ussd.database.operation.time")
                .description("Time taken for database operations")
                // Correct usage of .tags() method
                .tags("operation", "unknown", "table", "unknown")
                .register(meterRegistry);
    }

    /**
     * Gauge for tracking active USSD sessions count.
     * Provides real-time visibility into current system load.
     * Gauges are tied to an `AtomicInteger` which is then read by the `meterRegistry`.
     */
    @Bean
    public Gauge activeSessionsGauge() {
        return Gauge.builder("ussd.sessions.active", activeSessionsCount, AtomicInteger::get)
                .description("Number of currently active USSD sessions")
                .register(meterRegistry);
    }

    /**
     * Gauge for tracking queued requests waiting for processing.
     * Helps identify system bottlenecks and capacity issues.
     */
    @Bean
    public Gauge queuedRequestsGauge() {
        return Gauge.builder("ussd.requests.queued", queuedRequestsCount, AtomicInteger::get)
                .description("Number of requests currently queued for processing")
                .register(meterRegistry);
    }

    /**
     * Counter for tracking health check results.
     * Tags include: check_type, status, dependency_name.
     */
    @Bean
    public Counter healthCheckCounter() {
        return Counter.builder("ussd.health.checks")
                .description("Health check results for system dependencies")
                // Correct usage of .tags() method
                .tags("check_type", "application", "status", "unknown")
                .register(meterRegistry);
    }

    /**
     * Timer for measuring health check durations.
     * Tags include: check_type, dependency_name.
     */
    @Bean
    public Timer healthCheckTimer() {
        return Timer.builder("ussd.health.check.duration")
                .description("Time taken to complete health checks")
                // Correct usage of .tags() method
                .tags("check_type", "application")
                .register(meterRegistry);
    }

    // Utility methods for updating gauge values

    /**
     * Updates the active sessions count gauge.
     * Should be called when sessions are created or terminated.
     *
     * @param delta The change in active sessions count (positive for increase, negative for decrease)
     */
    public void updateActiveSessionsCount(int delta) {
        activeSessionsCount.addAndGet(delta);
    }

    /**
     * Sets the active sessions count to a specific value.
     * Useful for periodic synchronization with actual session store.
     *
     * @param count The current number of active sessions
     */
    public void setActiveSessionsCount(int count) {
        activeSessionsCount.set(count);
    }

    /**
     * Updates the queued requests count gauge.
     * Should be called when requests are queued or processed.
     *
     * @param delta The change in queued requests count (positive for increase, negative for decrease)
     */
    public void updateQueuedRequestsCount(int delta) {
        queuedRequestsCount.addAndGet(delta);
    }

    /**
     * Sets the queued requests count to a specific value.
     * Useful for periodic synchronization with actual queue state.
     *
     * @param count The current number of queued requests
     */
    public void setQueuedRequestsCount(int count) {
        queuedRequestsCount.set(count);
    }

    /**
     * Gets the current active sessions count.
     *
     * @return The current number of active sessions
     */
    public int getCurrentActiveSessionsCount() {
        return activeSessionsCount.get();
    }

    /**
     * Gets the current queued requests count.
     *
     * @return The current number of queued requests
     */
    public int getCurrentQueuedRequestsCount() {
        return queuedRequestsCount.get();
    }
}