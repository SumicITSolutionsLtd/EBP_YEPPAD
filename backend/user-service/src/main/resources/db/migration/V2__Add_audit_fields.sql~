-- Youth Connect Uganda - User Service Database Schema
-- Version: 1.1
-- Description: Add audit fields, performance indexes, analytics views, and automation

-- =================================================================================
-- ADD AUDIT FIELDS TO EXISTING TABLES
-- =================================================================================

-- Add created_by and updated_by to users table
ALTER TABLE users
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add created_by and updated_by to youth_profiles table
ALTER TABLE youth_profiles
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add created_by and updated_by to mentor_profiles table
ALTER TABLE mentor_profiles
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add created_by and updated_by to ngo_profiles table
ALTER TABLE ngo_profiles
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add created_by and updated_by to funder_profiles table
ALTER TABLE funder_profiles
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add created_by and updated_by to service_provider_profiles table
ALTER TABLE service_provider_profiles
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- Add audit fields to user_interests table
ALTER TABLE user_interests
ADD COLUMN created_by BIGINT NULL AFTER updated_at,
ADD COLUMN updated_by BIGINT NULL AFTER created_by,
ADD FOREIGN KEY (created_by) REFERENCES users(user_id) ON DELETE SET NULL,
ADD FOREIGN KEY (updated_by) REFERENCES users(user_id) ON DELETE SET NULL;

-- =================================================================================
-- ADD PERFORMANCE INDEXES
-- =================================================================================

-- Composite indexes for better query performance
CREATE INDEX idx_users_role_active_created ON users(role, is_active, created_at);
CREATE INDEX idx_youth_district_stage ON youth_profiles(district, business_stage, created_at);
CREATE INDEX idx_mentor_expertise_verified ON mentor_profiles(area_of_expertise(100), is_verified, availability_status);
CREATE INDEX idx_audit_user_created ON audit_trail(user_id, created_at);

-- Full-text indexes for search functionality
ALTER TABLE youth_profiles ADD FULLTEXT idx_youth_search (first_name, last_name, profession, skills, interests);
ALTER TABLE mentor_profiles ADD FULLTEXT idx_mentor_search (first_name, last_name, area_of_expertise, bio);
ALTER TABLE ngo_profiles ADD FULLTEXT idx_ngo_search (organisation_name, description, focus_areas);

-- =================================================================================
-- ADD DATA RETENTION POLICY FIELDS
-- =================================================================================

-- Add soft delete flag to all main tables
ALTER TABLE users ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE AFTER is_active;
ALTER TABLE youth_profiles ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE AFTER updated_by;
ALTER TABLE mentor_profiles ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE AFTER updated_by;
ALTER TABLE ngo_profiles ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE AFTER updated_by;
ALTER TABLE funder_profiles ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE AFTER updated_by;
ALTER TABLE service_provider_profiles ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE AFTER updated_by;

-- Add data retention timestamp
ALTER TABLE users ADD COLUMN deleted_at TIMESTAMP NULL AFTER is_deleted;
ALTER TABLE youth_profiles ADD COLUMN deleted_at TIMESTAMP NULL AFTER is_deleted;
ALTER TABLE mentor_profiles ADD COLUMN deleted_at TIMESTAMP NULL AFTER is_deleted;
ALTER TABLE ngo_profiles ADD COLUMN deleted_at TIMESTAMP NULL AFTER is_deleted;
ALTER TABLE funder_profiles ADD COLUMN deleted_at TIMESTAMP NULL AFTER is_deleted;
ALTER TABLE service_provider_profiles ADD COLUMN deleted_at TIMESTAMP NULL AFTER is_deleted;

-- Update indexes to include soft delete flag
CREATE INDEX idx_users_active_not_deleted ON users(is_active, is_deleted);
CREATE INDEX idx_youth_active_not_deleted ON youth_profiles(is_deleted, created_at);
CREATE INDEX idx_mentor_active_not_deleted ON mentor_profiles(is_deleted, availability_status);
CREATE INDEX idx_ngo_active_not_deleted ON ngo_profiles(is_deleted, is_verified);

-- =================================================================================
-- ANALYTICS VIEWS: Pre-defined views for common queries
-- =================================================================================

-- View: Recent user activity summary (30 days)
CREATE OR REPLACE VIEW v_recent_user_activity AS
SELECT
    u.user_id,
    u.email,
    u.role,
    CONCAT(COALESCE(yp.first_name, mp.first_name, np.organisation_name, fp.funder_name, sp.provider_name), ' ',
           COALESCE(yp.last_name, mp.last_name, '')) AS user_name,
    COUNT(ual.log_id) AS total_activities,
    COUNT(DISTINCT ual.activity_type) AS distinct_activity_types,
    MAX(ual.created_at) AS last_activity_time,
    COUNT(DISTINCT ual.session_id) AS session_count,
    COUNT(DISTINCT DATE(ual.created_at)) AS active_days
FROM users u
LEFT JOIN youth_profiles yp ON u.user_id = yp.user_id
LEFT JOIN mentor_profiles mp ON u.user_id = mp.user_id
LEFT JOIN ngo_profiles np ON u.user_id = np.user_id
LEFT JOIN funder_profiles fp ON u.user_id = fp.user_id
LEFT JOIN service_provider_profiles sp ON u.user_id = sp.user_id
LEFT JOIN user_activity_logs ual ON u.user_id = ual.user_id
    AND ual.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
WHERE u.is_active = TRUE AND u.is_deleted = FALSE
GROUP BY u.user_id, u.email, user_name, u.role;

-- View: Popular interests across all users
CREATE OR REPLACE VIEW v_popular_interests AS
SELECT
    interest_tag,
    interest_category,
    COUNT(DISTINCT user_id) AS user_count,
    AVG(CASE interest_level
        WHEN 'HIGH' THEN 3
        WHEN 'MEDIUM' THEN 2
        WHEN 'LOW' THEN 1
    END) AS avg_interest_level,
    SUM(interaction_count) AS total_interactions,
    MAX(last_interaction) AS most_recent_interaction,
    COUNT(CASE WHEN is_primary = TRUE THEN 1 END) AS primary_interest_count
FROM user_interests
WHERE is_active = TRUE
GROUP BY interest_tag, interest_category
ORDER BY user_count DESC, total_interactions DESC;

-- View: User engagement metrics
CREATE OR REPLACE VIEW v_user_engagement_metrics AS
SELECT
    u.user_id,
    u.email,
    u.role,
    u.created_at AS user_since,
    DATEDIFF(NOW(), u.created_at) AS days_since_registration,
    COUNT(DISTINCT DATE(ual.created_at)) AS active_days_last_30d,
    COUNT(ual.log_id) AS total_actions_last_30d,
    COUNT(DISTINCT ual.activity_type) AS unique_activity_types,
    AVG(ual.duration_seconds) AS avg_session_duration,
    COUNT(DISTINCT ual.target_id) AS unique_items_engaged,
    COUNT(DISTINCT ui.interest_tag) AS total_interests,
    MAX(ual.created_at) AS last_active_date
FROM users u
LEFT JOIN user_activity_logs ual ON u.user_id = ual.user_id
    AND ual.created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
LEFT JOIN user_interests ui ON u.user_id = ui.user_id AND ui.is_active = TRUE
WHERE u.is_active = TRUE AND u.is_deleted = FALSE
GROUP BY u.user_id, u.email, u.role, u.created_at;

-- View: Activity heatmap by hour and day
CREATE OR REPLACE VIEW v_activity_heatmap AS
SELECT
    DAYNAME(created_at) AS day_of_week,
    HOUR(created_at) AS hour_of_day,
    COUNT(*) AS activity_count,
    COUNT(DISTINCT user_id) AS unique_users,
    COUNT(DISTINCT session_id) AS unique_sessions
FROM user_activity_logs
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 30 DAY)
GROUP BY day_of_week, hour_of_day
ORDER BY
    FIELD(day_of_week, 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'),
    hour_of_day;

-- View: Interest trends over time
CREATE OR REPLACE VIEW v_interest_trends AS
SELECT
    interest_tag,
    interest_category,
    DATE_FORMAT(created_at, '%Y-%m') AS month_year,
    COUNT(*) AS new_interests_added,
    AVG(confidence_score) AS avg_confidence,
    COUNT(CASE WHEN source = 'USER_SELECTED' THEN 1 END) AS user_selected_count,
    COUNT(CASE WHEN source = 'AI_INFERRED' THEN 1 END) AS ai_inferred_count,
    COUNT(CASE WHEN source = 'ACTIVITY_BASED' THEN 1 END) AS activity_based_count
FROM user_interests
WHERE created_at >= DATE_SUB(NOW(), INTERVAL 6 MONTH)
GROUP BY interest_tag, interest_category, month_year
ORDER BY month_year DESC, new_interests_added DESC;

-- =================================================================================
-- DATABASE TRIGGERS: Automated data management
-- =================================================================================

DELIMITER //

-- Trigger: Auto-increment interaction count when user engages with interest-related content
CREATE TRIGGER trg_update_interest_interaction
AFTER INSERT ON user_activity_logs
FOR EACH ROW
BEGIN
    -- Update interaction count for matched interests based on activity tags
    IF NEW.tags IS NOT NULL THEN
        UPDATE user_interests ui
        SET
            ui.interaction_count = ui.interaction_count + 1,
            ui.last_interaction = NEW.created_at,
            ui.updated_at = CURRENT_TIMESTAMP
        WHERE ui.user_id = NEW.user_id
        AND ui.is_active = TRUE
        AND FIND_IN_SET(ui.interest_tag, REPLACE(NEW.tags, ' ', '')) > 0;
    END IF;

    -- Auto-promote interest level based on interaction frequency
    UPDATE user_interests
    SET
        interest_level = CASE
            WHEN interaction_count >= 50 THEN 'HIGH'
            WHEN interaction_count >= 20 THEN 'MEDIUM'
            ELSE 'LOW'
        END,
        updated_at = CURRENT_TIMESTAMP
    WHERE user_id = NEW.user_id
    AND is_active = TRUE
    AND source IN ('ACTIVITY_BASED', 'AI_INFERRED');
END//

-- Trigger: Track profile updates in audit trail
CREATE TRIGGER trg_audit_youth_profile_update
AFTER UPDATE ON youth_profiles
FOR EACH ROW
BEGIN
    INSERT INTO audit_trail (
        user_id,
        action_type,
        entity_type,
        entity_id,
        description,
        status
    ) VALUES (
        NEW.updated_by,
        'UPDATE_PROFILE',
        'YOUTH_PROFILE',
        NEW.profile_id,
        CONCAT('Youth profile updated for user_id: ', NEW.user_id),
        'SUCCESS'
    );
END//

-- Trigger: Track mentor profile updates
CREATE TRIGGER trg_audit_mentor_profile_update
AFTER UPDATE ON mentor_profiles
FOR EACH ROW
BEGIN
    INSERT INTO audit_trail (
        user_id,
        action_type,
        entity_type,
        entity_id,
        description,
        status
    ) VALUES (
        NEW.updated_by,
        'UPDATE_PROFILE',
        'MENTOR_PROFILE',
        NEW.mentor_profile_id,
        CONCAT('Mentor profile updated for user_id: ', NEW.user_id),
        'SUCCESS'
    );
END//

-- Trigger: Auto-cleanup expired sessions
CREATE TRIGGER trg_cleanup_expired_sessions
BEFORE INSERT ON user_sessions
FOR EACH ROW
BEGIN
    -- Delete expired sessions for the same user
    DELETE FROM user_sessions
    WHERE user_id = NEW.user_id
    AND expires_at < NOW();
END//

-- Trigger: Soft delete cascade for users
CREATE TRIGGER trg_soft_delete_user_cascade
AFTER UPDATE ON users
FOR EACH ROW
BEGIN
    IF NEW.is_deleted = TRUE AND OLD.is_deleted = FALSE THEN
        -- Soft delete all related profiles
        UPDATE youth_profiles SET is_deleted = TRUE, deleted_at = NEW.deleted_at
        WHERE user_id = NEW.user_id;

        UPDATE mentor_profiles SET is_deleted = TRUE, deleted_at = NEW.deleted_at
        WHERE user_id = NEW.user_id;

        UPDATE ngo_profiles SET is_deleted = TRUE, deleted_at = NEW.deleted_at
        WHERE user_id = NEW.user_id;

        UPDATE funder_profiles SET is_deleted = TRUE, deleted_at = NEW.deleted_at
        WHERE user_id = NEW.user_id;

        UPDATE service_provider_profiles SET is_deleted = TRUE, deleted_at = NEW.deleted_at
        WHERE user_id = NEW.user_id;

        -- Deactivate user interests
        UPDATE user_interests SET is_active = FALSE
        WHERE user_id = NEW.user_id;
    END IF;
END//

DELIMITER ;

-- =================================================================================
-- STORED PROCEDURES: Common operations
-- =================================================================================

DELIMITER //

-- Procedure: Get user's top interests with pagination
CREATE PROCEDURE sp_get_user_top_interests(
    IN p_user_id BIGINT,
    IN p_limit INT,
    IN p_offset INT
)
BEGIN
    SELECT
        interest_tag,
        interest_level,
        interest_category,
        interaction_count,
        source,
        confidence_score,
        is_primary,
        last_interaction,
        created_at
    FROM user_interests
    WHERE user_id = p_user_id
    AND is_active = TRUE
    ORDER BY
        is_primary DESC,
        CASE interest_level
            WHEN 'HIGH' THEN 3
            WHEN 'MEDIUM' THEN 2
            WHEN 'LOW' THEN 1
        END DESC,
        interaction_count DESC,
        confidence_score DESC
    LIMIT p_limit OFFSET p_offset;
END//

-- Procedure: Get user activity summary with date range
CREATE PROCEDURE sp_get_user_activity_summary(
    IN p_user_id BIGINT,
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    SELECT
        activity_type,
        activity_category,
        COUNT(*) AS activity_count,
        COUNT(DISTINCT target_id) AS unique_targets,
        COUNT(DISTINCT DATE(created_at)) AS active_days,
        AVG(duration_seconds) AS avg_duration,
        MAX(created_at) AS last_activity,
        COUNT(CASE WHEN action_result = 'SUCCESS' THEN 1 END) AS successful_actions,
        COUNT(CASE WHEN action_result = 'FAILED' THEN 1 END) AS failed_actions
    FROM user_activity_logs
    WHERE user_id = p_user_id
    AND DATE(created_at) BETWEEN p_start_date AND p_end_date
    GROUP BY activity_type, activity_category
    ORDER BY activity_count DESC;
END//

-- Procedure: Track activity and auto-infer interests
CREATE PROCEDURE sp_track_user_activity(
    IN p_user_id BIGINT,
    IN p_activity_type VARCHAR(50),
    IN p_activity_category VARCHAR(50),
    IN p_target_id BIGINT,
    IN p_target_type VARCHAR(50),
    IN p_target_name VARCHAR(255),
    IN p_session_id VARCHAR(255),
    IN p_tags TEXT,
    IN p_metadata JSON
)
BEGIN
    DECLARE v_log_id BIGINT;

    -- Insert activity log
    INSERT INTO user_activity_logs (
        user_id,
        activity_type,
        activity_category,
        target_id,
        target_type,
        target_name,
        session_id,
        tags,
        metadata,
        device_type
    ) VALUES (
        p_user_id,
        p_activity_type,
        p_activity_category,
        p_target_id,
        p_target_type,
        p_target_name,
        p_session_id,
        p_tags,
        p_metadata,
        'WEB'
    );

    SET v_log_id = LAST_INSERT_ID();

    -- Return the log ID
    SELECT v_log_id AS log_id, 'Activity tracked successfully' AS message;
END//

-- Procedure: Bulk add user interests
CREATE PROCEDURE sp_bulk_add_user_interests(
    IN p_user_id BIGINT,
    IN p_interest_tags TEXT,
    IN p_interest_level ENUM('LOW', 'MEDIUM', 'HIGH'),
    IN p_source ENUM('USER_SELECTED', 'AI_INFERRED', 'ACTIVITY_BASED', 'SURVEY', 'IMPORTED'),
    IN p_created_by BIGINT
)
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_tag VARCHAR(50);
    DECLARE v_position INT DEFAULT 1;
    DECLARE v_comma_pos INT;

    -- Loop through comma-separated tags
    WHILE v_position > 0 DO
        SET v_comma_pos = LOCATE(',', p_interest_tags, v_position);

        IF v_comma_pos = 0 THEN
            SET v_tag = TRIM(SUBSTRING(p_interest_tags, v_position));
            SET v_position = 0;
        ELSE
            SET v_tag = TRIM(SUBSTRING(p_interest_tags, v_position, v_comma_pos - v_position));
            SET v_position = v_comma_pos + 1;
        END IF;

        -- Insert interest if not exists
        INSERT INTO user_interests (
            user_id,
            interest_tag,
            interest_level,
            source,
            created_by
        ) VALUES (
            p_user_id,
            v_tag,
            p_interest_level,
            p_source,
            p_created_by
        ) ON DUPLICATE KEY UPDATE
            interest_level = VALUES(interest_level),
            updated_at = CURRENT_TIMESTAMP,
            updated_by = p_created_by;

    END WHILE;

    SELECT CONCAT('Interests added successfully for user ', p_user_id) AS message;
END//

-- Procedure: Get recommended users based on shared interests
CREATE PROCEDURE sp_get_recommended_connections(
    IN p_user_id BIGINT,
    IN p_limit INT
)
BEGIN
    SELECT
        u.user_id,
        u.email,
        u.role,
        CONCAT(COALESCE(yp.first_name, mp.first_name), ' ',
               COALESCE(yp.last_name, mp.last_name)) AS full_name,
        COUNT(DISTINCT ui2.interest_tag) AS shared_interests,
        GROUP_CONCAT(DISTINCT ui2.interest_tag ORDER BY ui2.interest_tag) AS common_tags
    FROM user_interests ui1
    INNER JOIN user_interests ui2 ON ui1.interest_tag = ui2.interest_tag
    INNER JOIN users u ON ui2.user_id = u.user_id
    LEFT JOIN youth_profiles yp ON u.user_id = yp.user_id
    LEFT JOIN mentor_profiles mp ON u.user_id = mp.user_id
    WHERE ui1.user_id = p_user_id
    AND ui2.user_id != p_user_id
    AND ui1.is_active = TRUE
    AND ui2.is_active = TRUE
    AND u.is_active = TRUE
    AND u.is_deleted = FALSE
    GROUP BY u.user_id, u.email, u.role, full_name
    ORDER BY shared_interests DESC, u.created_at DESC
    LIMIT p_limit;
END//

-- Procedure: Generate user engagement report
CREATE PROCEDURE sp_generate_engagement_report(
    IN p_start_date DATE,
    IN p_end_date DATE
)
BEGIN
    SELECT
        u.role,
        COUNT(DISTINCT u.user_id) AS total_users,
        COUNT(DISTINCT ual.user_id) AS active_users,
        ROUND(COUNT(DISTINCT ual.user_id) / COUNT(DISTINCT u.user_id) * 100, 2) AS engagement_rate,
        COUNT(ual.log_id) AS total_activities,
        ROUND(COUNT(ual.log_id) / COUNT(DISTINCT ual.user_id), 2) AS avg_activities_per_user,
        COUNT(DISTINCT ual.session_id) AS total_sessions
    FROM users u
    LEFT JOIN user_activity_logs ual ON u.user_id = ual.user_id
        AND DATE(ual.created_at) BETWEEN p_start_date AND p_end_date
    WHERE u.is_active = TRUE AND u.is_deleted = FALSE
    GROUP BY u.role
    ORDER BY total_users DESC;
END//

DELIMITER ;

-- =================================================================================
-- VERIFICATION: Confirm all changes applied successfully
-- =================================================================================

-- Verify new columns added
SELECT
    TABLE_NAME,
    COLUMN_NAME,
    DATA_TYPE,
    IS_NULLABLE,
    COLUMN_DEFAULT,
    COLUMN_COMMENT
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_NAME IN ('users', 'youth_profiles', 'mentor_profiles', 'ngo_profiles',
                   'funder_profiles', 'service_provider_profiles', 'user_interests')
AND COLUMN_NAME IN ('created_by', 'updated_by', 'is_deleted', 'deleted_at')
ORDER BY TABLE_NAME, ORDINAL_POSITION;

-- Verify new indexes created
SELECT
    TABLE_NAME,
    INDEX_NAME,
    GROUP_CONCAT(COLUMN_NAME ORDER BY SEQ_IN_INDEX) AS COLUMNS,
    INDEX_TYPE,
    NON_UNIQUE
FROM INFORMATION_SCHEMA.STATISTICS
WHERE TABLE_SCHEMA = DATABASE()
AND INDEX_NAME LIKE 'idx_%'
GROUP BY TABLE_NAME, INDEX_NAME, INDEX_TYPE, NON_UNIQUE
ORDER BY TABLE_NAME, INDEX_NAME;

-- Verify views created
SELECT
    TABLE_NAME AS VIEW_NAME,
    TABLE_COMMENT
FROM INFORMATION_SCHEMA.TABLES
WHERE TABLE_SCHEMA = DATABASE()
AND TABLE_TYPE = 'VIEW'
ORDER BY TABLE_NAME;

-- Verify triggers created
SELECT
    TRIGGER_NAME,
    EVENT_MANIPULATION,
    EVENT_OBJECT_TABLE,
    ACTION_TIMING
FROM INFORMATION_SCHEMA.TRIGGERS
WHERE TRIGGER_SCHEMA = DATABASE()
ORDER BY EVENT_OBJECT_TABLE, ACTION_TIMING, EVENT_MANIPULATION;

-- Verify stored procedures created
SELECT
    ROUTINE_NAME,
    ROUTINE_TYPE,
    DATA_TYPE AS RETURN_TYPE,
    ROUTINE_COMMENT
FROM INFORMATION_SCHEMA.ROUTINES
WHERE ROUTINE_SCHEMA = DATABASE()
AND ROUTINE_TYPE = 'PROCEDURE'
ORDER BY ROUTINE_NAME;

-- Test sample data counts
SELECT 'User Interests' AS metric, COUNT(*) AS count FROM user_interests
UNION ALL
SELECT 'Activity Logs', COUNT(*) FROM user_activity_logs
UNION ALL
SELECT 'Active Users', COUNT(*) FROM users WHERE is_active = TRUE AND is_deleted = FALSE
UNION ALL
SELECT 'Youth Profiles', COUNT(*) FROM youth_profiles WHERE is_deleted = FALSE
UNION ALL
SELECT 'Mentor Profiles', COUNT(*) FROM mentor_profiles WHERE is_deleted = FALSE;

-- =================================================================================
-- MAINTENANCE NOTES
-- =================================================================================
/*
REGULAR MAINTENANCE TASKS:

1. Archive old activity logs (run monthly):
   - Archive activities older than 6 months
   - Keep last 6 months in main table for performance

2. Update interest confidence scores (run weekly):
   - Recalculate confidence scores based on recent activity
   - Identify trending interests

3. Clean up inactive users (run quarterly):
   - Mark users as deleted if inactive for 12+ months
   - Send reactivation emails before deletion

4. Optimize tables (run monthly):
   - OPTIMIZE TABLE user_activity_logs;
   - ANALYZE TABLE user_interests;

5. Review and update indexes (run quarterly):
   - Analyze slow queries
   - Add/remove indexes based on usage patterns
*/